<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>이미지 → 코드 (JSON/Base64) 변환 — 서버리스</title>
  <style>
    :root { --bg:#0b1020; --card:#121a35; --muted:#98a2b3; --acc:#7c9cff; --line:#233055; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Apple SD Gothic Neo, Helvetica, Arial, sans-serif; background:var(--bg); color:#e6eaf2; }
    header { padding: 24px; border-bottom:1px solid var(--line); backdrop-filter: blur(8px); position: sticky; top:0; background: linear-gradient(180deg, rgba(11,16,32,.9), rgba(11,16,32,.7)); z-index: 10; }
    h1 { margin:0; font-size: clamp(18px, 2.6vw, 28px); letter-spacing: .3px; }
    main { padding: 24px; max-width: 1100px; margin: 0 auto; display:grid; gap:20px; grid-template-columns: 1fr 420px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }
    .card { background: var(--card); border:1px solid var(--line); border-radius: 16px; padding: 16px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hint { color: var(--muted); font-size: 12px; }
    label { display:block; font-size:13px; color:#c9d3eb; margin-bottom:8px; }
    input[type="file"] { width:100%; padding:10px; background:#0e1530; border:1px dashed #2a3a6d; color:#d6e1ff; border-radius:10px; }
    button { appearance:none; border:1px solid #2a3a6d; background: #0d1230; color:#e6ecff; padding:10px 14px; border-radius:12px; cursor:pointer; transition:.15s ease; }
    button.primary { border-color: transparent; background: linear-gradient(180deg, #5b79ff, #4863f7); color:white; box-shadow: 0 6px 18px rgba(92, 121, 255, .25); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    textarea { width:100%; min-height:160px; resize:vertical; border-radius:12px; background:#0b1330; border:1px solid #25356a; color:#e9eeff; padding:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
    .grid { display:grid; grid-template-columns: repeat(2, 1fr); gap:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; font-size:12px; color:#d7e1ff; }
    .pill { display:inline-block; padding:5px 10px; border:1px solid #2a3a6d; border-radius:999px; font-size:12px; color:#c7d2fe; background:#0e1532; }
    .ok { color:#86efac; }
    .warn { color:#fde68a; }
    .err { color:#fda4af; }
    canvas { width:100%; background:#0b1330; border-radius:12px; border:1px solid #25356a; }
    .footer { color: var(--muted); font-size: 12px; margin-top:8px; }
    .small { font-size:12px; color:#b8c2df; }
  </style>
</head>
<body>
  <header>
    <h1>이미지 → 코드(JSON/Base64) 변환 · 서버리스(OpenCV.js)</h1>
    <div class="small">브라우저 안에서만 실행됩니다 · 파일은 업로드되지 않습니다</div>
  </header>

  <main>
    <section class="card">
      <div class="grid">
        <div>
          <label>1) 템플릿 자동 로드 (호스트 고정 세트)</label>
<div class="hint">/templates 폴더의 PNG들을 자동으로 불러옵니다 · 파일명=코드(예: <span class="mono">152.png</span>)</div>
<div id=\"tplList\" class=\"hint\" style=\"margin-top:6px\">로드 대기…</div>
<div style=\"margin-top:6px\"><progress id=\"tplProgress\" max=\"100\" value=\"0\" style=\"width:100%\"></progress></div>
        <div>
          <label>2) 스크린샷 이미지 선택</label>
          <input id="imgInput" type="file" accept="image/*" />
          <div class="hint">예상: 7×7 격자 이미지(총 49칸)</div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <span class="pill">빈칸 RGB: <span class="mono" id="emptyRGBView">[246,238,213]</span></span>
        <span class="pill">면적 허용오차: <span id="tolView">±10%</span></span>
        <span class="pill">그리드: 7×7</span>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="runBtn" class="primary" disabled>변환 실행</button>
        <button id="dlJsonBtn" disabled>JSON 다운로드</button>
        <button id="dlB64Btn" disabled>Base64 다운로드</button>
        <span id="status" class="hint"></span>
      </div>

      <div class="grid" style="margin-top:12px">
        <div>
          <label>JSON 결과</label>
          <textarea id="jsonOut" readonly></textarea>
        </div>
        <div>
          <label>Base64 결과</label>
          <textarea id="b64Out" readonly></textarea>
        </div>
      </div>

      <div class="footer">참고: Python <span class="mono">capture2code.py</span>의 로직을 OpenCV.js로 포팅한 브라우저 전용 구현입니다.</div>
    </section>

    <aside class="card">
      <label>미리보기</label>
      <canvas id="canvas" width="800" height="800"></canvas>
      <div id="log" class="hint" style="margin-top:10px; white-space:pre-wrap"></div>
    </aside>
  </main>

  <!-- OpenCV.js (WASM) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="cvLoadError()"></script>
  <script>
    // ==== 구성값 (Python 버전과 동일한 기본값) ====
    const GRID_SIZE = 7;
    const NUM_CELLS = GRID_SIZE * GRID_SIZE;
    const TARGET_EMPTY_RGB = [246, 238, 213];
    const AREA_TOLERANCE = 0.10; // 중앙값 대비 ±10%

    const els = {
      imgInput: document.getElementById('imgInput'),
      runBtn: document.getElementById('runBtn'),
      dlJsonBtn: document.getElementById('dlJsonBtn'),
      dlB64Btn: document.getElementById('dlB64Btn'),
      jsonOut: document.getElementById('jsonOut'),
      b64Out: document.getElementById('b64Out'),
      status: document.getElementById('status'),
      canvas: document.getElementById('canvas'),
      log: document.getElementById('log'),
      tplList: document.getElementById('tplList'),
      tplProgress: document.getElementById('tplProgress')
    };

    let cvReady = false;
    let templates = {}; // { code(string): grayMat }
    let srcMat = null;  // 이미지 Mat (RGB)

    // 고정 세트 템플릿 설정 — 필요에 맞게 수정
    const TEMPLATE_BASE = './templates'; // 동일 호스트 정적 경로
    const TEMPLATE_CODES = [152, 153, 201]; // 예시: 배포 시 실제 코드 목록으로 교체

    function onOpenCvReady() {
      cv['onRuntimeInitialized'] = async () => {
        cvReady = true;
        info('OpenCV.js 로드 완료');
        try {
          await preloadTemplates();
          info('템플릿 로드 완료');
        } catch(err){ error('템플릿 로드 실패: '+err.message); }
        enableRunIfReady();
      };
    }
    function cvLoadError(){ error('OpenCV.js 로드 실패'); }

    function info(msg){ els.status.textContent = msg; log(msg); }
    function warn(msg){ els.status.innerHTML = `<span class=warn>${msg}</span>`; log(msg); }
    function error(msg){ els.status.innerHTML = `<span class=err>${msg}</span>`; log(msg); }
    function log(msg){ els.log.textContent += `\n${msg}`; }

    // 파일→Image→Canvas→cv.Mat 로딩
    function loadImageFile(file){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = () => {
          const ctx = els.canvas.getContext('2d');
          // 캔버스 정사각 보정
          const size = Math.min(els.canvas.width, els.canvas.height);
          ctx.clearRect(0,0,els.canvas.width, els.canvas.height);
          ctx.drawImage(img, 0, 0, size, size);
          const mat = cv.imread(els.canvas);
          resolve(mat);
        };
        img.onerror = () => reject(new Error('이미지 로드 실패'));
        img.src = URL.createObjectURL(file);
      });
    }

    async function handleTemplates(files){
      templates = {};
      for (const f of files){
        if (!f.name.toLowerCase().endsWith('.png')) continue;
        const code = f.name.replace(/\.png$/i,'');
        const mat = await fileToMat(f);
        let gray = new cv.Mat();
        cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
        mat.delete();
        templates[code] = gray; // 저장
      }
      info(`템플릿 ${Object.keys(templates).length}개 로드`);
      enableRunIfReady();
    }

    function fileToMat(file){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>{
          const c = document.createElement('canvas');
          c.width = img.width; c.height = img.height;
          c.getContext('2d').drawImage(img,0,0);
          const m = cv.imread(c);
          resolve(m);
        };
        img.onerror = ()=>reject(new Error('템플릿 로드 실패'));
        img.src = URL.createObjectURL(file);
      });
    }

    function enableRunIfReady(){
      const ready = (cvReady && Object.keys(templates).length>0 && srcMat);
      els.runBtn.disabled = !ready;
    }

    // 템플릿 파일 입력(a.k.a. 수동 업로드) 제거됨 — 고정 세트 자동 로드 사용

    els.imgInput.addEventListener('change', async (e)=>{
      try{
        if (srcMat){ srcMat.delete(); srcMat=null; }
        const [file] = e.target.files; if(!file){ return; }
        const bgr = await loadImageFile(file);
        // RGBA/BGR 통일 → RGB
        srcMat = new cv.Mat();
        if (bgr.type() === cv.CV_8UC4){ cv.cvtColor(bgr, srcMat, cv.COLOR_RGBA2RGB); bgr.delete(); }
        else { cv.cvtColor(bgr, srcMat, cv.COLOR_BGR2RGB); bgr.delete(); }
        info('스크린샷 로드 완료');
        enableRunIfReady();
      }catch(err){ error(err.message); }
    });

    els.runBtn.addEventListener('click', async ()=>{
      try{
        if (!(srcMat && Object.keys(templates).length)) return;
        info('처리 중…');
        const result = processImage(srcMat);
        const jsonStr = JSON.stringify(result, null, 2);
        els.jsonOut.value = jsonStr;
        els.b64Out.value = btoa(jsonStr);
        els.dlJsonBtn.disabled = false;
        els.dlB64Btn.disabled = false;
        info('완료 ✅');
      }catch(err){ error('실패: '+err.message); console.error(err); }
    });

    els.dlJsonBtn.addEventListener('click', ()=> downloadText('payload.json', els.jsonOut.value));
    els.dlB64Btn.addEventListener('click', ()=> downloadText('payload.base64.txt', els.b64Out.value));

    function downloadText(name, text){
      const blob = new Blob([text], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob); a.download = name; a.click();
    }

    // 템플릿 자동 로더
    async function preloadTemplates(){
      templates = {g`;
        try{
          const mat = await urlToGrayMat(url);
          templates[String(code)] = mat;
          loaded.push(code);
          names.push(`${code}.png`);
        }catch(err){
          missing.push(code);
          console.warn('템플릿 누락:', url, err);
        } finally {
          i++;
          if (els.tplProgress) els.tplProgress.value = i;
        }
      }
      if (loaded.length){
        const list = names.map(n=>`<code>${n}</code>`).join(', ');
        els.tplList.innerHTML = `로드됨 <span class=ok>${loaded.length}</span>개: ${list}` +
          (missing.length ? `<br>누락 <span class=warn>${missing.length}</span>개: ${missing.map(c=>`<code>${c}.png</code>`).join(', ')}` : '');
      } else {
        els.tplList.innerHTML = `<span class=err>로드된 템플릿이 없습니다. TEMPLATE_BASE / TEMPLATE_CODES 및 /templates 경로를 확인하세요.</span>`;
      }
    }
      const loaded = [];
      for (const code of TEMPLATE_CODES){
        const url = `${TEMPLATE_BASE}/${code}.png`;
        const mat = await urlToGrayMat(url);
        templates[String(code)] = mat;
        loaded.push(code);
      }
      els.tplList.textContent = `로드된 템플릿: ${loaded.join(', ')}`;
    }

    function urlToGrayMat(url){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = 'anonymous'; // 동일 도메인이면 무시됨
        img.onload = ()=>{
          const c = document.createElement('canvas');
          c.width = img.width; c.height = img.height;
          c.getContext('2d').drawImage(img,0,0);
          const rgba = cv.imread(c);
          let gray = new cv.Mat();
          cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);
          rgba.delete();
          resolve(gray);
        };
        img.onerror = ()=>reject(new Error('이미지 로드 실패: '+url));
        img.src = url;
      });
    }

    // ===================== 핵심 처리 파이프라인 =====================
    function processImage(imgRGB){
      // 1) 빈칸(배경) 마스크 → 가장 큰 BG 연결요소만 남기고 반전
      const nonEmptyMask = buildNonEmptyMask(imgRGB, TARGET_EMPTY_RGB);

      // 2) 라벨링
      const comps = connectedComponents(nonEmptyMask);

      // 3) 49개 격자 성분 선택
      const gridLabels = selectGridComponents(comps.stats, NUM_CELLS, AREA_TOLERANCE);

      // 4) 병력 매핑 (템플릿 매칭)
      const troopLayout = buildTroopLayout(imgRGB, comps.stats, comps.centroids, gridLabels, templates);

      // 5) 페이로드 생성
      return buildPayload(troopLayout, {});
    }

    function buildNonEmptyMask(imgRGB, emptyRGB){
      const src = imgRGB;
      let mask = new cv.Mat();
      const lo = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(emptyRGB[0], emptyRGB[1], emptyRGB[2]));
      const hi = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(emptyRGB[0], emptyRGB[1], emptyRGB[2]));
      cv.inRange(src, lo, hi, mask); // empty == 255
      lo.delete(); hi.delete();

      // 가장 큰 BG 연결요소만 유지
      let labels = new cv.Mat();
      let stats = new cv.Mat();
      let centroids = new cv.Mat();
      cv.connectedComponentsWithStats(mask, labels, stats, centroids, 4, cv.CV_32S);
      if (stats.rows <= 1) {
        // BG 없음 → non-empty = 반전
        cv.bitwise_not(mask, mask);
        return mask;
      }
      // BG 후보들 중 면적 최대인 라벨 찾기 (0 제외)
      let maxArea = -1, maxIdx = 1;
      for (let i=1; i<stats.rows; i++){
        const area = stats.intPtr(i, cv.CC_STAT_AREA)[0];
        if (area > maxArea){ maxArea = area; maxIdx = i; }
      }
      // 해당 라벨만 255로 만든 후 반전
      let refinedBG = new cv.Mat.zeros(mask.rows, mask.cols, cv.CV_8U);
      for (let r=0; r<labels.rows; r++){
        for (let c=0; c<labels.cols; c++){
          if (labels.intPtr(r,c)[0] === maxIdx) refinedBG.ucharPtr(r,c)[0] = 255;
        }
      }
      let nonEmpty = new cv.Mat();
      cv.bitwise_not(refinedBG, nonEmpty);
      mask.delete(); labels.delete(); stats.delete(); centroids.delete(); refinedBG.delete();
      return nonEmpty;
    }

    function connectedComponents(mask){
      let labels = new cv.Mat();
      let stats = new cv.Mat();
      let centroids = new cv.Mat();
      cv.connectedComponentsWithStats(mask, labels, stats, centroids, 4, cv.CV_32S);
      return { labels, stats, centroids };
    }

    function selectGridComponents(stats, expected, tol){
      // stats: rows × 5(+)
      const areas = [];
      for (let i=1; i<stats.rows; i++){ // 0은 전체 배경
        areas.push(stats.intPtr(i, cv.CC_STAT_AREA)[0]);
      }
      if (areas.length < expected) throw new Error(`성분 부족: ${areas.length} < ${expected}`);

      const med = median(areas);
      const lo = med * (1 - tol), hi = med * (1 + tol);

      const candidates = [];
      for (let i=1; i<stats.rows; i++){
        const area = stats.intPtr(i, cv.CC_STAT_AREA)[0];
        if (area>=lo && area<=hi) candidates.push({label:i, area});
      }
      if (candidates.length < expected){
        // 면적 내 후보가 부족하면 면적 큰 순서로 보정
        const all = [];
        for (let i=1; i<stats.rows; i++) all.push({label:i, area: stats.intPtr(i, cv.CC_STAT_AREA)[0]});
        all.sort((a,b)=>b.area-a.area);
        return all.slice(0, expected).map(o=>o.label);
      }
      candidates.sort((a,b)=>b.area-a.area);
      return candidates.slice(0, expected).map(o=>o.label);
    }

    function sortLabelsRowMajor(stats, centroids, labels){
      const pts = labels.map(lbl => ({
        lbl,
        x: centroids.doublePtr(lbl, 0)[0],
        y: centroids.doublePtr(lbl, 1)[0]
      }));
      const ys = pts.map(p=>p.y);
      const yMin = Math.min(...ys), yMax = Math.max(...ys);
      const rowStep = (yMax - yMin + 1e-6) / GRID_SIZE;
      function rowIndex(y){
        let r = Math.floor((y - yMin) / rowStep);
        return Math.min(Math.max(r, 0), GRID_SIZE-1);
      }
      pts.sort((a,b)=>{
        const ra = rowIndex(a.y), rb = rowIndex(b.y);
        if (ra !== rb) return ra - rb; // row asc
        return a.x - b.x; // x asc
      });
      return pts.map(p=>p.lbl);
    }

    function extractPatchGray(imgRGB, statRow){
      const x = statRow.intPtr(0, cv.CC_STAT_LEFT)[0];
      const y = statRow.intPtr(0, cv.CC_STAT_TOP)[0];
      const w = statRow.intPtr(0, cv.CC_STAT_WIDTH)[0];
      const h = statRow.intPtr(0, cv.CC_STAT_HEIGHT)[0];
      const rect = new cv.Rect(x,y,w,h);
      const patch = imgRGB.roi(rect);
      let gray = new cv.Mat();
      cv.cvtColor(patch, gray, cv.COLOR_RGB2GRAY);
      patch.delete();
      const y0 = Math.floor(h*0.20), y1 = Math.floor(h*0.60);
      const x0 = Math.floor(w*0.10), x1 = Math.floor(w*0.90);
      const roi = gray.roi(new cv.Rect(x0, y0, Math.max(1,x1-x0), Math.max(1,y1-y0)));
      gray.delete();
      return roi; // Mat(roi) 반환 (호출 측에서 delete 필요)
    }

    function mse(a, b){
      // a,b: CV_8U 단일채널 동일 크기
      let diff = new cv.Mat();
      cv.absdiff(a, b, diff);
      cv.multiply(diff, diff, diff); // square
      const mean = cv.mean(diff)[0];
      diff.delete();
      return mean;
    }

    function matchTemplateCode(patchGray, templates){
      const size = patchGray.size();
      let best = {code:null, score:Infinity};
      for (const [code, tGray] of Object.entries(templates)){
        let resized = new cv.Mat();
        cv.resize(tGray, resized, size, 0, 0, cv.INTER_AREA);
        const score = mse(patchGray, resized);
        resized.delete();
        if (score < best.score){ best = {code, score}; }
      }
      if (!best.code) throw new Error('템플릿 매칭 실패');
      return best.code;
    }

    function buildTroopLayout(imgRGB, stats, centroids, labels, templates){
      const ordered = sortLabelsRowMajor(stats, centroids, labels);
      const layout = {};
      for (let idx=0; idx<ordered.length; idx++){
        const lbl = ordered[idx];
        const r = Math.floor(idx / GRID_SIZE), c = idx % GRID_SIZE;
        const statRow = stats.row(lbl);
        const patch = extractPatchGray(imgRGB, statRow);
        const code = matchTemplateCode(patch, templates);
        layout[`${r}${c}`] = parseInt(code, 10);
        patch.delete(); statRow.delete();
      }
      return layout;
    }

    function buildPayload(troopLayout, heroLayout){
      return {
        GameMode: 0,
        troopLayout,
        heroLayout: heroLayout || {},
        armyLayout: null,
      };
    }

    // 유틸
    function median(arr){ const s=[...arr].sort((a,b)=>a-b); const m=(s.length-1)/2; return (s[Math.floor(m)] + s[Math.ceil(m)]) / 2; }
  </script>
</body>
</html>
