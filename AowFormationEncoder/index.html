<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>반죽 생성기</title>
  <style>
    :root { --bg:#0b1020; --card:#121a35; --muted:#98a2b3; --acc:#7c9cff; --line:#233055; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Apple SD Gothic Neo, Helvetica, Arial, sans-serif; background:var(--bg); color:#e6eaf2; }
    header { padding: 24px; border-bottom:1px solid var(--line); backdrop-filter: blur(8px); position: sticky; top:0; background: linear-gradient(180deg, rgba(11,16,32,.9), rgba(11,16,32,.7)); z-index: 10; }
    h1 { margin:0; font-size: clamp(18px, 2.6vw, 28px); letter-spacing: .3px; }
    main { padding: 24px; max-width: 1100px; margin: 0 auto; display:grid; gap:20px; grid-template-columns: 1fr 420px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; gap:16px; padding:16px; } .grid { grid-template-columns: 1fr; } textarea { min-height:140px; } }
    .card { background: var(--card); border:1px solid var(--line); border-radius: 16px; padding: 16px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hint { color: var(--muted); font-size: 12px; }
    label { display:block; font-size:13px; color:#c9d3eb; margin-bottom:8px; }
    input[type="file"] { width:100%; padding:10px; background:#0e1530; border:1px dashed #2a3a6d; color:#d6e1ff; border-radius:10px; }
    button { appearance:none; border:1px solid #2a3a6d; background: #0d1230; color:#e6ecff; padding:10px 14px; border-radius:12px; cursor:pointer; transition:.15s ease; }
    button.primary { border-color: transparent; background: linear-gradient(180deg, #5b79ff, #4863f7); color:white; box-shadow: 0 6px 18px rgba(92, 121, 255, .25); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    textarea { width:100%; min-height:160px; resize:vertical; border-radius:12px; background:#0b1330; border:1px solid #25356a; color:#e9eeff; padding:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
    .grid { display:grid; grid-template-columns: repeat(2, 1fr); gap:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; font-size:12px; color:#d7e1ff; }
    .pill { display:inline-block; padding:5px 10px; border:1px solid #2a3a6d; border-radius:999px; font-size:12px; color:#c7d2fe; background:#0e1532; }
    .ok { color:#86efac; }
    .warn { color:#fde68a; }
    .err { color:#fda4af; }
    canvas { width:100%; height:auto; background:#0b1330; border-radius:12px; border:1px solid #25356a; }
    .footer { color: var(--muted); font-size: 12px; margin-top:8px; }
    .small { font-size:12px; color:#b8c2df; }
  </style>
</head>
<body>
  <header>
    <h1>반죽 생성기</h1>
    
  </header>

  <main>
    <section class="card">
      <div class="grid">
        <div>
          <label>1) 템플릿</label></div>
        <div>
          <label>2) 스크린샷 이미지 선택</label>
          <input id="imgInput" type="file" accept="image/*" />
          <div class="hint">예상: 7×7 격자 이미지(총 49칸)</div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <span class="pill">빈칸 RGB: <span class="mono" id="emptyRGBView">[246,238,213]</span></span>
        <span class="pill">그리드: 7×7</span>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="runBtn" class="primary" disabled>변환 실행</button>
        <button id="copyJsonBtn">JSON 복사</button>
        <button id="copyB64Btn">Base64 복사</button>
        <span id="status" class="hint"></span>
      </div>

      <div class="grid" style="margin-top:12px">
        <div>
          <label>JSON 결과</label>
          <textarea id="jsonOut" readonly></textarea>
        </div>
        <div>
          <label>Base64 결과</label>
          <textarea id="b64Out" readonly></textarea>
        </div>
      </div>

      
    </section>

    <aside class="card">
      <label>미리보기</label>
      <canvas id="canvas" width="800" height="800"></canvas>
      <div id="log" class="hint" style="margin-top:10px; white-space:pre-wrap"></div>
    </aside>
  </main>

  <!-- OpenCV.js (WASM) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="cvLoadError()"></script>
  <script>
    // ==== 구성값 (Python 버전과 동일한 기본값) ====
    const GRID_SIZE = 7;
    const NUM_CELLS = GRID_SIZE * GRID_SIZE;
    const TARGET_EMPTY_RGB = [246, 238, 213];
    const AREA_TOLERANCE = 0.10; // 중앙값 대비 ±10%

    const els = {
      imgInput: document.getElementById('imgInput'),
      runBtn: document.getElementById('runBtn'),
      copyJsonBtn: document.getElementById('copyJsonBtn'),
      copyB64Btn: document.getElementById('copyB64Btn'),
      jsonOut: document.getElementById('jsonOut'),
      b64Out: document.getElementById('b64Out'),
      status: document.getElementById('status'),
      canvas: document.getElementById('canvas'),
      log: document.getElementById('log')
    };

    let cvReady = false;
    let templates = {}; // { code(string): grayMat }
    let srcMat = null;  // 이미지 Mat (RGB)

    // 고정 세트 템플릿 설정 — 필요에 맞게 수정
    const TEMPLATE_BASE = './templates'; // 동일 호스트 정적 경로
    const TEMPLATE_CODES = [
      101,102,103,104,105,106,107,109,110,111,112,113,
      124,125,126,132,133,134,142,143,144,145,146,147,148,149,150,151,
      159,160,161,162,163,164,166,168,173,178,179,180,181,182,183,186,
      188,189,191,192,193,198,199,200,201,202,203,210,211,212,213,214,
      215,216,217,219,220
    ];

    function onOpenCvReady() {
      cv['onRuntimeInitialized'] = async () => {
        cvReady = true;
        info('OpenCV.js 로드 완료');
        try {
          await preloadTemplates();
          info('템플릿 로드 완료');
        } catch(err){ error('템플릿 로드 실패: '+err.message); }
        enableRunIfReady();
      };
    }
    function cvLoadError(){ error('OpenCV.js 로드 실패'); }

    function info(msg){ els.status.textContent = msg; log(msg); }
    function warn(msg){ els.status.innerHTML = `<span class=warn>${msg}</span>`; log(msg); }
    function error(msg){ els.status.innerHTML = `<span class=err>${msg}</span>`; log(msg); }
    function log(msg){ els.log.textContent += `\n${msg}`; }

    // 파일→Image→Canvas→cv.Mat 로딩
    function loadImageFile(file){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = () => {
          const ctx = els.canvas.getContext('2d');
          const size = Math.min(els.canvas.width, els.canvas.height);
          ctx.clearRect(0,0,els.canvas.width, els.canvas.height);
          const cw = els.canvas.width, ch = els.canvas.height;
          const scale = Math.min(cw / img.width, ch / img.height);
          const dw = Math.floor(img.width * scale);
          const dh = Math.floor(img.height * scale);
          const dx = Math.floor((cw - dw) / 2);
          const dy = Math.floor((ch - dh) / 2);
          ctx.fillStyle = '#0b1330';
          ctx.fillRect(0,0,cw,ch);
          ctx.drawImage(img, dx, dy, dw, dh);
          const mat = cv.imread(els.canvas);
          resolve(mat);
        };
        img.onerror = () => reject(new Error('이미지 로드 실패'));
        img.src = URL.createObjectURL(file);
      });
    }

    function enableRunIfReady(){
      const ready = (cvReady && Object.keys(templates).length>0 && srcMat);
      els.runBtn.disabled = !ready;
    }

    els.imgInput.addEventListener('change', async (e)=>{
      try{
        if (srcMat){ srcMat.delete(); srcMat=null; }
        const [file] = e.target.files; if(!file){ return; }
        const bgr = await loadImageFile(file);
        srcMat = new cv.Mat();
        if (bgr.type() === cv.CV_8UC4){ cv.cvtColor(bgr, srcMat, cv.COLOR_RGBA2RGB); bgr.delete(); }
        else { cv.cvtColor(bgr, srcMat, cv.COLOR_BGR2RGB); bgr.delete(); }
        info('스크린샷 로드 완료');
        enableRunIfReady();
      }catch(err){ error(err.message); }
    });

    els.runBtn.addEventListener('click', async ()=>{
      try{
        if (!(srcMat && Object.keys(templates).length)) return;
        info('처리 중…');
        const result = processImage(srcMat);
        const jsonStr = JSON.stringify(result, null, 2);
        els.jsonOut.value = jsonStr;
        els.b64Out.value = btoa(jsonStr);
        els.copyJsonBtn.disabled = false;
        els.copyB64Btn.disabled = false;
        info('완료 ✅');
      }catch(err){ error('실패: '+err.message); console.error(err); }
    });

    els.copyJsonBtn.addEventListener('click', ()=> copyToClipboard(els.jsonOut.value, 'JSON'));
    els.copyB64Btn.addEventListener('click', ()=> copyToClipboard(els.b64Out.value, 'Base64'));

    function copyToClipboard(text, label){
      if (!text) return;
      navigator.clipboard.writeText(text).then(()=>{
        info(`${label} 복사 완료 ✅`);
      }).catch(()=>{
        // clipboard 실패 시 폴백
        const ta = document.createElement('textarea');
        ta.value = text; document.body.appendChild(ta); ta.select();
        try { document.execCommand('copy'); info(`${label} 복사 완료 ✅`);} catch(e){ error(`${label} 복사 실패`);} 
        document.body.removeChild(ta);
      });
    });

    // 템플릿 자동 로더
    async function preloadTemplates(){
      templates = {};
      const loaded = [];
      for (const code of TEMPLATE_CODES){
        const url = `${TEMPLATE_BASE}/${code}.png`;
        const mat = await urlToGrayMat(url);
        templates[String(code)] = mat;
        loaded.push(code);
      }
    }

    function urlToGrayMat(url){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = ()=>{
          const c = document.createElement('canvas');
          c.width = img.width; c.height = img.height;
          c.getContext('2d').drawImage(img,0,0);
          const rgba = cv.imread(c);
          let gray = new cv.Mat();
          cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);
          rgba.delete();
          resolve(gray);
        };
        img.onerror = ()=>reject(new Error('이미지 로드 실패: '+url));
        img.src = url;
      });
    }

    // ===================== 핵심 처리 파이프라인 =====================
    function processImage(imgRGB){
      const nonEmptyMask = buildNonEmptyMask(imgRGB, TARGET_EMPTY_RGB);
      const comps = connectedComponents(nonEmptyMask);
      const gridLabels = selectGridComponents(comps.stats, NUM_CELLS, AREA_TOLERANCE);
      const troopLayout = buildTroopLayout(imgRGB, comps.stats, comps.centroids, gridLabels, templates);
      return buildPayload(troopLayout, {});
    }

    function buildNonEmptyMask(imgRGB, emptyRGB){
      const src = imgRGB;
      let mask = new cv.Mat();
      const lo = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(emptyRGB[0], emptyRGB[1], emptyRGB[2]));
      const hi = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(emptyRGB[0], emptyRGB[1], emptyRGB[2]));
      cv.inRange(src, lo, hi, mask);
      lo.delete(); hi.delete();

      let labels = new cv.Mat();
      let stats = new cv.Mat();
      let centroids = new cv.Mat();
      cv.connectedComponentsWithStats(mask, labels, stats, centroids, 4, cv.CV_32S);
      if (stats.rows <= 1) {
        cv.bitwise_not(mask, mask);
        return mask;
      }
      let maxArea = -1, maxIdx = 1;
      for (let i=1; i<stats.rows; i++){
        const area = stats.intPtr(i, cv.CC_STAT_AREA)[0];
        if (area > maxArea){ maxArea = area; maxIdx = i; }
      }
      let refinedBG = new cv.Mat.zeros(mask.rows, mask.cols, cv.CV_8U);
      for (let r=0; r<labels.rows; r++){
        for (let c=0; c<labels.cols; c++){
          if (labels.intPtr(r,c)[0] === maxIdx) refinedBG.ucharPtr(r,c)[0] = 255;
        }
      }
      let nonEmpty = new cv.Mat();
      cv.bitwise_not(refinedBG, nonEmpty);
      mask.delete(); labels.delete(); stats.delete(); centroids.delete(); refinedBG.delete();
      return nonEmpty;
    }

    function connectedComponents(mask){
      let labels = new cv.Mat();
